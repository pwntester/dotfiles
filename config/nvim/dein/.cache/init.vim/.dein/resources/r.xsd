<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
		   targetNamespace="xmlns://www.fortifysoftware.com/schema/rules"
		   xmlns="xmlns://www.fortifysoftware.com/schema/rules"
		   xmlns:mask="xmlns://www.fortifysoftware.com/schema/mask"
		   blockDefault="#all" version="3.13" xml:lang="EN">

	<xs:import namespace="xmlns://www.fortifysoftware.com/schema/mask" schemaLocation="mask-3.2.xsd"/>


	<!-- Root Elements: RulePack, Rules, RulePackDefinition -->

	<xs:element name="RulePack">
		<xs:annotation>
			<xs:documentation>RulePack is a top level element that contains a description of the rule pack, localization information, masks and the actual rules.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rulePackDesc">
					<xs:sequence>
						<xs:element ref="Rules" minOccurs="1" maxOccurs="1"/>
						<xs:element ref="Masks" minOccurs="0" maxOccurs="1"/>
						<xs:element ref="Localization" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element ref="CodeLibraries" minOccurs="0" maxOccurs="1"/>
						<xs:element ref="ExtendedCodeLibraries" minOccurs="0" maxOccurs="1"/>
						<xs:element ref="ResolutionLibraries" minOccurs="0" maxOccurs="1"/>
						<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- placeholder for future extensions -->
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="RulePackDefinition">
		<xs:annotation>
			<xs:documentation>FortifyUndocumented</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rulePackDesc">
					<xs:sequence>
						<!-- this is just a placeholder until we find out what expressions look like  -->
						<xs:element name="Expression" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="Rules">
		<xs:annotation>
			<xs:documentation>You can use Rules as the root element when creating a rule file that is not a RulePack or a child element of RulePack.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Notes" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="RuleDefinitions" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="LabelDefinitions" minOccurs="0" maxOccurs="1"/>
				<!-- xs:element ref="FunctionIdentifier" minOccurs="0" maxOccurs="unbounded"/ --> <!-- Removed as of 3.4 -->
				<xs:element ref="Descriptions" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="ControlflowStateStrings" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="TaintFlagDeclarations" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="TaintFlagDescriptions" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="Coverage" minOccurs="0" maxOccurs="1">
					<xs:annotation><xs:appinfo>Since 3.4</xs:appinfo></xs:annotation>
				</xs:element>
				<xs:element ref="Script" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation><xs:appinfo>Since 3.4</xs:appinfo></xs:annotation>
				</xs:element>
				<xs:element ref="ScriptDefinitions" minOccurs="0" maxOccurs="1"/>
				<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- placeholder for future extensions -->
			</xs:sequence>
			<xs:attribute name="version" type="xs:string" use="required">
			<xs:annotation>
			<xs:documentation>The version of the schema for which the rules are written.
			</xs:documentation>
			</xs:annotation></xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="RuleDefinitions">
		<xs:annotation>
			<xs:documentation>Contains the actual rules.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="DataflowSourceRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="DataflowEntryPointRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="DataflowPassthroughRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="DataflowSinkRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="DataflowCleanseRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="SemanticRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="ControlflowRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="ControlflowTransition" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="StructuralRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="ConfigurationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="ContentRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="StatisticalRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="InternalRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="InputSetRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="BufferCopyRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="AllocationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="StringLengthRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="NonReturningRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="AliasRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="MapRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="DeprecationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="SuppressionRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="CharacterizationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="ControlflowActionPrototype" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="GlobalFieldRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="GlobalClassRule" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="ResultFilterRule" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="CustomDescriptionRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="ScriptedCallGraphRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="TypeDescriptionRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="PathTypeRule" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="TypeImplementationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="FieldRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="DispatcherRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- placeholder for future extensions -->
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:complexType name="rulePackDesc">
		<xs:all>
			<xs:element name="RulePackID" type="xs:string"  minOccurs="1" maxOccurs="1">
				<xs:annotation>
						<xs:documentation>A unique string that identifies the rulepack.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SKU" type="xs:string"  minOccurs="1" maxOccurs="1"/>
			<xs:element name="License" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>FortifyUndocumented</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Name" type="xs:string" minOccurs="1" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>The display name of the rulepack.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Expiration" type="xs:date"  minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>FortifyUndocumented</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Activated" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
				<xs:annotation>
					<xs:documentation>FortifyUndocumented</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Version" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Use to differentiate revisions of a rulepack.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Language" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Indicates the source language for which all rules in this rulepack are written.  Fortify SCA only loads this rulepack when processing source files of the specified language.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Description" type="xs:string" minOccurs="1" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Describes the rulepack.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Locale" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:appinfo>Since 3.3</xs:appinfo>
					<xs:documentation>The locale for which the rulepack is built.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
	</xs:complexType>

	<xs:element name="LabelDefinitions">
		<xs:annotation>
			<xs:documentation>Contains rules that place labels.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="DeprecationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="SuppressionRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="CharacterizationRule" minOccurs="0" maxOccurs="unbounded"/>
				<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- placeholder for future extensions -->
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="Masks">
		<xs:annotation>
			<xs:documentation>FortifyUndocumented</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="mask:Mask" minOccurs="1" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="revision" type="xs:string" use="optional"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="CodeLibraries">
		<xs:annotation>
			<xs:documentation>This allows a rulepack to contain one or more libraries of source code.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="CodeLibrary" minOccurs="1" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="CodeLibrary">
		<xs:annotation>
			<xs:documentation>This contains a single lump of text, which is source code for a code library.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:all>
			<xs:element name="Text">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			</xs:all>
			<xs:attribute name="language" type="languageSpecifier" use="required">
						<xs:annotation>
							<xs:documentation>Indicates the language of the library.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="ExtendedCodeLibraries">
		<xs:annotation>
			<xs:documentation>This allows a rulepack to contain one or more libraries of source code</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ExtendedCodeLibrary" minOccurs="1" maxOccurs="unbounded"/>
				<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- placeholder for future extensions -->
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="ExtendedCodeLibrary">
		<xs:annotation>
			<xs:documentation>This contains a single lump of text, which is source code for a code library.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:all>
			<xs:element name="Text">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			</xs:all>
			<xs:attribute name="language" type="languageSpecifier" use="required">
						<xs:annotation>
							<xs:documentation>Indicates the language of the library extension.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
			<xs:attribute name="filename" type="xs:string" use="required"/>
			<xs:anyAttribute>
				<xs:annotation><xs:appinfo>Since 3.4</xs:appinfo></xs:annotation>
			</xs:anyAttribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="ResolutionLibraries">
		<xs:annotation>
			<xs:documentation>Additional source code used for resolution at translation time</xs:documentation>
			<xs:appinfo>Since 3.9</xs:appinfo>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="ResolutionLibrary" minOccurs="1" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>A single library used for resolution</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:all>
							<xs:element name="Text">
								<xs:simpleType>
									<xs:restriction base="xs:string">
										<xs:whiteSpace value="preserve"/>
									</xs:restriction>
								</xs:simpleType>
							</xs:element>
						</xs:all>
						<xs:attribute name="formatVersion" type="xs:string" use="required">
							<xs:annotation>
								<xs:documentation>The rule-schema version for which the library is written.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="language" type="languageSpecifier" use="required">
							<xs:annotation>
								<xs:documentation>Indicates the language of the library extension.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="filename" type="xs:string" use="optional"/>
					</xs:complexType>
				</xs:element>
				<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- placeholder for future extensions -->
			</xs:sequence>
		</xs:complexType>
	</xs:element>


	<xs:element name="ScriptDefinitions">
		<xs:annotation>
			<xs:documentation>This is a top-level container for all the global scripts for a rulepack.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="Script">
					<xs:annotation>
						<xs:documentation>Deprecated in version 3.9. Use the ScriptDefinition element instead.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="ScriptDefinition" type="scriptType"/>
				<xs:any/> <!-- placeholder for future extensions -->
			</xs:choice>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<!-- Type Definitions -->

	<xs:complexType name="rule">
		<xs:sequence>
			<xs:element ref="MetaInfo" minOccurs="0"/>
			<xs:element name="RuleID" type="xs:string" minOccurs="1">
				<xs:annotation>
					<xs:documentation>Each rule must have a globally unique Rule ID. When you insert a rule in XML View of AWB a unique ID is automatically generated.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Label" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Text included in the output wherever the rule is applied.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="Notes" minOccurs="0" maxOccurs="1"/>
			<xs:element name="Script" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation><xs:appinfo>Since 3.4</xs:appinfo></xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="formatVersion" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The rule-schema version for which the rule is written.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="vulnRule">
				<xs:annotation>
					<xs:documentation>When this type of rule is matched, produces an issue.</xs:documentation>
				</xs:annotation>
		<xs:complexContent>
			<xs:extension base="rule">
				<xs:sequence>
					<xs:element name="VulnKingdom" type="xs:string" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The name of the Kingdom assigned to issues produced by the rule.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="VulnCategory" type="xs:string" minOccurs="1" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The name of the Category assigned to issues produced by the rule.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="VulnSubcategory" type="xs:string" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The name of the Subcategory assigned to issues produced by the rule.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultSeverity" minOccurs="1">
						<xs:annotation>
							<xs:documentation>The severity level value, 1.0-5.0, assigned to issues produced by the rule.</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:float">
								<xs:minInclusive value="1.0"/>
								<xs:maxInclusive value="5.0"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
					<xs:element ref="Description" minOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>

	</xs:complexType>

	<xs:simpleType name="argumentSpecifier">
		<xs:annotation>
			<xs:documentation>Allows multiple function arguments in a comma separated list. Expressions in the following forms are accepted:
x - A single argument where x is a number, "this", "return", or "globals".  When x is a number, it indicates the xth argument to the function, starting from 0.
x.member - A single member field of the given argument
n... - All arguments after and including argument n
n1-n2 - All arguments between and including n1 and n2</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="([0-9]+|[0-9]+\.\.\.|[0-9]+-[0-9]+|this|return|globals)(\.[\$a-zA-Z0-9_\-]+)*(,([0-9]+|[0-9]+\.\.\.|[0-9]+-[0-9]+|this|return|globals)(\.[\$a-zA-Z0-9_\-]+)*)*"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="singleArgumentSpecifier">
		<xs:annotation>
			<xs:documentation>Allows one argument of a function. Values accepted are 'this', 'return', or n, where n is number indicating the argument index starting from 0.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[0-9]+|this|return"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="sizeSpecifier">
		<xs:annotation>
			<xs:documentation>Describes a quantity of data written, read, or returned by a function call.  A sizeSpecifier may be one of three types:
value: The quantity is passed as an argument to the call or returned from the call.  The arg attribute indicates which argument receives or returns the quantitiy.
stringLengh: The quantity of data in question is dependent on the length of the string passed to the argument specified with the arg attribute.
formatString: The qunatity of data is controlled by the interpretation of a format string, which is passed as the argument specified with the arg attribute.
For each of these types, the final quantity may be modified by a fixed amount specified by the addend attribute.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required">
			<xs:annotation><xs:documentation>Indicates the units, either 'value', 'stringLength', or 'formatString'.</xs:documentation></xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="value"/>
					<xs:enumeration value="stringLength"/>
					<xs:enumeration value="formatString"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="addend" type="xs:integer" use="optional">
				<xs:annotation>
					<xs:documentation>Indicates the number of units automatically added to the value described by type and arg.</xs:documentation>
				</xs:annotation>
		</xs:attribute>
		<xs:attribute name="arg" type="argumentSpecifier" use="required">
				<xs:annotation>
					<xs:documentation>Indicates the argument that specifies the amount of data to be copied.</xs:documentation>
				</xs:annotation>
		</xs:attribute>
 	</xs:complexType>

	<xs:attributeGroup name="referenceable">
		<xs:attribute name="ref" type="xs:string" use="optional">
				<xs:annotation>
					<xs:documentation>References a description defined in the Descriptions element. </xs:documentation>
				</xs:annotation>
		</xs:attribute>
		<xs:attribute name="id" type="xs:string" use="optional">
				<xs:annotation>
					<xs:documentation>Unique identifier that allows the description to be referenced from a rule definition. Only valid if Description is a child of Descriptions.</xs:documentation>
				</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>

	<xs:complexType name="descriptionElement">
		<xs:attributeGroup ref="referenceable"/>
	</xs:complexType>

	<xs:simpleType name="textElement">
		<xs:restriction base="xs:string">
			<xs:whiteSpace value="preserve"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="descriptionTextElement">
		<xs:simpleContent>
			<xs:extension base="textElement">
				<xs:attributeGroup ref="referenceable"/>
				<xs:attribute name="append" type="xs:boolean" default="false"/>
				<xs:attribute name="formatVersion" type="xs:string" use="optional">
					<xs:annotation><xs:appinfo>Since 3.4</xs:appinfo></xs:annotation>
				</xs:attribute>
				<xs:anyAttribute>
					<xs:annotation><xs:documentation>Since 3.3</xs:documentation></xs:annotation>
				</xs:anyAttribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="matchType">
				<xs:annotation>
					<xs:documentation>Matches either an exact string or Java-style expression.</xs:documentation>
				</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element ref="Value"/>
			<xs:element ref="Pattern"/>
		</xs:choice>
	</xs:complexType>

	<xs:simpleType name="taintFlagExpression">
		<xs:annotation>
			<xs:documentation>Turns taint flags on or off when the rule is applied.  The expression is a comma-separated list of flags. Each flag is preceded by a + or - to indicate whether the flag is added or removed. Typical exambles would include +NETWORK,+NOT_NULL_TERMINATED for a socket read, and -NOT_NULL_TERMINATED for a passthrough that adds null termination to a buffer.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[+\-][a-zA-Z_][a-zA-Z0-9_]*(, *[+\-][a-zA-Z_][a-zA-Z0-9_]*)*"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="languageSpecifier">
			<xs:annotation>
				<xs:documentation>The Fortify SCA supported languages.</xs:documentation>
			</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="cpp"/>
			<xs:enumeration value="objc"/>
			<xs:enumeration value="java"/>
			<xs:enumeration value="jsp"/>
			<xs:enumeration value="sql"/>
			<xs:enumeration value="tsql"/>
			<xs:enumeration value="plsql"/>
			<xs:enumeration value="dotnet"/>
			<xs:enumeration value="php"/>
			<xs:enumeration value="asp"/>
			<xs:enumeration value="vb"/>
			<xs:enumeration value="cobol"/>
			<xs:enumeration value="python"/>
			<xs:enumeration value="abap"/>
			<xs:enumeration value="ruby"/>
			<xs:enumeration value="cfml">
				<xs:annotation><xs:documentation>FortifyUndocumented</xs:documentation></xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="javascript">
				<xs:annotation><xs:documentation>FortifyUndocumented</xs:documentation></xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="actionscript">
				<xs:annotation><xs:documentation>FortifyUndocumented</xs:documentation></xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="configuration"/>
		</xs:restriction>
	</xs:simpleType>

	<!-- Elements -->

	<xs:element name="Notes">
		<xs:annotation>
			<xs:documentation>Provides a location to keep comments about a rule or rule file.</xs:documentation>
		</xs:annotation>
		<xs:simpleType>
			<xs:restriction base="xs:string">
				<xs:whiteSpace value="preserve"/>
			</xs:restriction>
		</xs:simpleType>
	</xs:element>

	<!-- - - -  Dataflow Rules - - - -->

	<xs:complexType name="dataflowRule">
		<xs:annotation>
			<xs:documentation>Describes a pattern to identify sites in the code that produce, transfer, or transform tainted data. The rule matches any call site in the code where a function matching the FunctionIdentifier and the conditions may be called.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="rule">
				<xs:sequence>
					<xs:element name="TaintFlags" type="taintFlagExpression" minOccurs="0" maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Mechanism for distinguishing between various types of tainted data. Rather than treating data as either tainted or not tainted, it is possible to associate arbitrary strings, called taint flags, with data that either originates from or passes through particular functions for the purpose of differentiation. Taint flags are used by Fortify SCA to indicate where specific data comes from and to identify specific operations that have been performed on it.
						</xs:documentation>
				</xs:annotation>
					</xs:element>
					<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element ref="Conditional" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="language" use="required" type="languageSpecifier">
					<xs:annotation>
						<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:element name="DataflowSinkRule">
		<xs:annotation>
			<xs:documentation>Describes a pattern to identify sites in the code where a vulnerability is reported if the site is reached by tainted data. The pattern consists of a FunctionIdentifier, set of arguments and optionally a Conditional.  It matches function calls in the source code where a function that matches the FunctionIdentifier is called and one of the arguments specified in InArguments is tainted.
If multiple Sinks are specified as part of a DataflowSinkRule, each sink must be triggered in order for the rule to produce a result.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:element name="Sink" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>If any of the parameters listed are tainted and do not have a validated flag, then an issue with the assigned vulnerability category and severity appears in the results of a source code analysis.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="InArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>Triggers the rule, if tainted data reaches the any of InArguments.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element ref="Conditional" minOccurs="0" maxOccurs="1"/>
									<xs:element name="ReportAs" type="xs:string" minOccurs="0" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>If this attribute is present, the trace to this sink will be included as a child of the sink node. The value of this element is the descriptive text for the trace. Only applies to non-primary sinks.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
								<xs:attribute name="primary" type="xs:boolean" use="optional" default="false">
									<xs:annotation>
										<xs:documentation>Indicates that this sink is the primary sink to in results. Only label one sink in the list as primary. When no sinks are set to primary, the first in the list is implicitly the primary sink.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
						<xs:element name="Source" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>If any Source elements are present in a sink rule, the rule emits an issue only when for every such source, the taint it describes reaches some sink.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="OutArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>Indicates the arguments considered tainted.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="TaintFlags" type="taintFlagExpression" minOccurs="1" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>The taint type(s) injected at this point.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="ReportAs" type="xs:string" minOccurs="0" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>If this attribute is present, the trace from this source to a sink will be included as a child of the sink node. The value of this element is the descriptive text for the trace.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="unbounded"/>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="PathTypeRule">
		<xs:annotation>
			<xs:documentation>Lorem ipsum</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="Type" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>This is the resultant type. Things found at the ends of matching paths will be considered to be of this type. Quasitypes defined by TypeDescriptionRules can be used here, by supplying the relevant NamespaceName. If the NamespaceName is ommitted, the language-default namespace is assumed. The elements here are literal strings, case-sensitive or nor per the surrounding language. These identify a single specific type.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="NamespaceName" type="xs:string" minOccurs="0" maxOccurs="1" />
									<xs:element name="ClassName" type="xs:string" minOccurs="1" maxOccurs="1" />
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="BaseType" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>A base type from which the access path may be considered to originate. If the BaseType element is omitted, the path is instead assumed to originate from a global root object, which is meaningful only for javascript and javascript-like languages. The elements here are match types, so this may match a range of actual types.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element ref="NamespaceName" minOccurs="1" maxOccurs="1" />
									<xs:element ref="ClassName" minOccurs="1" maxOccurs="1" />
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="Path" type="xs:string" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Dotted string defining the access path.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TypeDescriptionRule">
		<xs:annotation>
			<xs:documentation>Each of these rules defines a Quasi-type which is no more and no less than a list of attribute names and methods names. Interesting objects in javascript and other dynamic languages may be identified by which attributes and methods they have, and these rules exist to give such objects a type-like object which can be used as a type by other rules. This is essentially "duck typing".</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="TypeName" type="xs:string" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The name of the Quasitype defined by this shape rule.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="InheritsFrom" type="xs:string" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The name of another Quasitype from which this one inherits. The Quasitype defined by this rule is simply assumed to have all the attributes and methods defined by the inheritted-from Quasitype in addition to any defined by its own body.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Methods" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Zero of more method names which an object should have to be considered an instance of this quasitype</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Name" type="xs:string" minOccurs="0" maxOccurs="unbounded">
										<xs:annotation>
											<xs:documentation>A single method name. Case sensitivity is language-specific, and not specified here.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="Attributes" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Zero of more attribute names which an object should have to be considered an instance of this quasitype</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Name" type="xs:string" minOccurs="0" maxOccurs="unbounded">
										<xs:annotation>
											<xs:documentation>A single attribute name. Case sensitivity is language-specific, and not specified here.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="DataflowSourceRule">
		<xs:annotation>
			<xs:documentation>Describes a site in the source code that produces tainted data.  At any call site in the code that matches the rule, Fortify SCA considers the listed arguments tainted.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="dataflowRule">
					<xs:sequence>
						<xs:element name="OutArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Indicates the arguments considered tainted.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="DataflowEntryPointRule">
		<xs:annotation>
			<xs:documentation>Describes a site in the source code that tainted data enters the program.  This should not be confused with an execution entry point; while DataflowEntryPointRules may be used to describe how tainted data enters a program at an execution entry point (such as main()), they can also be used to describe amy function whose arguments are tainted by convetion on entry into the function (such as interface methods called by a J2EE container).</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="dataflowRule">
					<xs:sequence>
						<xs:element name="InArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>Indicates the tainted arguments.</xs:documentation>
										</xs:annotation>
									</xs:element>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="DataflowPassthroughRule">
		<xs:annotation>
			<xs:documentation>Describes a call site in the source code where tainted data is transferred from one argument to another.  Also use the rule to transform the taint by applying or removing taint flags.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="dataflowRule">
					<xs:sequence>
						<xs:element name="InArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>If any of the parameters listed here are tainted, then all of the parameters listed in the Out Arguments are considered tainted after a call to the specified function.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="OutArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>All of the parameters listed here are considered tainted if any of the parameters in the In Arguments are tainted in a call to the specified function.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="DataflowCleanseRule">
		<xs:annotation>
			<xs:documentation>Cleanse rules describe functions that terminate data flow paths and render user input passing through them safe for subsequent use. All of the parameters listed in the OutArguments are considered completely cleansed of taint after a call to the specified function
 Note: Except for taint added by the TaintFlags element. A taint flag preceded by - has no effect because all flags are removed from data received by this function.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="dataflowRule">
					<xs:sequence>
						<xs:element name="OutArguments" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>All of the listed arguments are considered completely cleansed of taint after a call to the specified function.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Web Framework Rules - - - -->

	<xs:element name="FieldRule">
		<xs:annotation>
			<xs:documentation>Add artificial fields defined by this rule to a type. A field is needed but not defined in application code. For example, adding an HttpSession as a field of HttpServletRequest.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="FieldDeclarations">
							<xs:annotation>
								<xs:documentation>
									The fields to be added into the enclosing type.
								</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Field" minOccurs="1" maxOccurs="unbounded">
										<xs:annotation>
											<xs:documentation> A field must have a name and type.</xs:documentation>
										</xs:annotation>
										<xs:complexType>
											<xs:sequence>
												<xs:element name="Name" type="xs:string" minOccurs="1" maxOccurs="1"/>
												<xs:element name="Type" type="xs:string" minOccurs="1" maxOccurs="1"/>
												<xs:element name="Getter" type="getterType" minOccurs="1" maxOccurs="1"/>
											</xs:sequence>
										</xs:complexType>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="EnclosingType" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The enclosing type into which fields defined in this rule are to be inserted.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:all>
									<xs:element ref="NamespaceName" minOccurs="0" maxOccurs="1"/>
									<xs:element ref="ClassName" minOccurs="1" maxOccurs="1"/>
									<xs:element name="ClassLabel" type="xs:string" minOccurs="0" maxOccurs="1"/>
									<xs:element ref="ApplyTo" minOccurs="0" maxOccurs="1"/>
								</xs:all>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:complexType name="getterType">
		<xs:complexContent>
			<xs:extension base="functionIdentifierType">
				<xs:sequence>
					<xs:element name="ValueArg" type="singleArgumentSpecifier" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="dispatcherCallType">
		<xs:complexContent>
			<xs:extension base="functionIdentifierType">
				<xs:sequence>
					<xs:element name="PathArg" type="xs:integer" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="dispatchingCallType">
		<xs:complexContent>
			<xs:extension base="functionIdentifierType">
				<xs:sequence>
					<xs:element name="ResourceArg" type="xs:integer" minOccurs="0" maxOccurs="1"/>
					<xs:element name="RequestArg" type="xs:integer" minOccurs="0" maxOccurs="1"/>
					<xs:element name="ResponseArg" type="xs:integer" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:element name="DispatcherRule">
		<xs:annotation>
			<xs:documentation>This rule models data and control flow transfers among different server resources. An implicit analysis object "Dispatcher" is created When a function call specified in the rule is matched. A dispatcher has two types of methods: a forward function and an include function. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="DispatcherCall" type="dispatcherCallType" minOccurs="0" maxOccurs="1"/>
						<xs:element name="ForwardFunction" type="dispatchingCallType" minOccurs="1" maxOccurs="1"/>
						<xs:element name="IncludeFunction" type="dispatchingCallType" minOccurs="0" maxOccurs="1"/>
						<xs:element name="JspPathPrefixes" minOccurs="0" maxOccurs="0">
							<xs:annotation>
								<xs:documentation>Path prefixes for JSP pages. Applications may use a path that is relative from a subdirectory of the web root directory, which is the directory containing the WEB-INFO directory. The path segement from the root directory to the subdirectory forms an entry in JspPathPrefixes and is used to resolve the correct JSP page.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="JspPathPrefix" type="xs:string" minOccurs="1" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Input Set Rule - - - -->

	<xs:element name="InputSetRule">
		<xs:annotation>
			<xs:documentation>FortifyUndocumented</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:all>
						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="1"/>
						<xs:element name="InputFile" type="xs:string" minOccurs="1" maxOccurs="1"/>
						<xs:element name="Arg" type="argumentSpecifier" minOccurs="1" maxOccurs="1"/>
 					</xs:all>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Semantic Rules - - - -->

	<xs:element name="SemanticRule">
	<xs:annotation>
		<xs:documentation>Matches calls to a function with a specified pattern in the source code.  The rule consists of a FunctionIdentifier, a set of argument specifiers depending on the type of the rule, and optionally a Conditional to control triggering of the rule. </xs:documentation>
	</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:element name="Type" minOccurs="1">
							<xs:annotation>
								<xs:documentation>Identifies the type of vulnerabilities the rule finds. If none of the optional elements are defined, the rule unconditionally flags the specified function.</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="bufferOverflow"/>
									<xs:enumeration value="formatStringPrint"/>
									<xs:enumeration value="formatStringScan"/>
									<xs:enumeration value="processControl"/>
									<xs:enumeration value="uncheckedReturnValue"/>
									<xs:enumeration value="memory"/>
									<xs:enumeration value="default"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>

						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="unbounded"/>

						<xs:element name="ControlArgument" type="argumentSpecifier" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The parameters to a function that receives a bound on the amount of data to consider in a copy operation.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SourceArgument" type="argumentSpecifier" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The parameters to a function that receives a source buffer to be used in a copy operation.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DestinationArgument" type="argumentSpecifier" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The parameters to a function that receives a destination buffer to be used in a copy operation.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="FormatArgument" type="argumentSpecifier" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The parameters to a function that receives a format string to be used in formatting input or output.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ExecutionPathArgument" type="argumentSpecifier" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The parameters to a function that receives the path of a command to be executed.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="Conditional" minOccurs="0"/>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  ControlFlow Rules - - - -->

	<xs:element name="ControlflowRule">
		<xs:annotation>
			<xs:documentation>Unlike data flow or semantic rules, a control flow rule does not specify a single function; instead, it specifies a sequence of program elements (which could be function calls or other entities in a program). This definition, which goes in the Definition field of the rule, resembles a simple programming language.
Each rule definition defines a state machine. Each state machine has exactly one start state, one or more error states, and any number of intermediate states. The machine always has a current state. If the current state is ever an error state, a vulnerability is reported.
States are connected by transitions. Each transition has a source state, a destination state, and some number of patterns. If a transition's source state is the current state and one of that transition's patterns matches a fragment of the program, then the transition's destination state becomes the new current state. In this case, the machine is said to have transitioned from the source state to the destination state. The program fragment is referred to as the "input" to the pattern.</xs:documentation>
			</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:element name="Limit" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation></xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element ref="FunctionIdentifier" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element ref="FunctionCallIdentifier" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element ref="ControlflowRuleFlag" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element name="PrimaryState" minOccurs="0" maxOccurs="1" type="xs:string">
							<xs:annotation>
								<xs:documentation>A string that defines the machine state of the vulnerability.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Definition" minOccurs="1">
						<xs:annotation><xs:documentation>Defines a state machine. The definition of a machine consists of two major parts: declarations and transitions. Each state machine has exactly one start state, one or more error states, and any number of intermediate states. The machine always has a current state.If the current state is ever an error state, a vulnerability is reported.
						States are connected by transitions. Each transition has a source state, a destination state, and some number of patterns. If a transition's source state is the current state and one of that transition's patterns matches a fragment of the program, then the transition's destination state becomes the new current state. In this case, the machine is said to have transitioned from the source state to the destination state. The program fragment is referred to as the "input" to the pattern.</xs:documentation>
						</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:whiteSpace value="preserve"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="ControlflowTransition">
		<xs:annotation>
			<xs:documentation>Adds transitions to a control flow rule.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="ParentRuleID" type="xs:string" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Identifies the rule to which this rule adds transitions.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="FunctionIdentifier" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element ref="FunctionCallIdentifier" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element name="DefinitionLanguage" type="xs:string" minOccurs="0" maxOccurs="1" default="controlflow">
							<xs:annotation><xs:documentation>Indicates the language in which the state definition is written.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Definition" minOccurs="1" maxOccurs="1">
						<xs:annotation><xs:documentation>Defines a state machine. The definition of a machine consists of two major parts: declarations and transitions. Each state machine has exactly one start state, one or more error states, and any number of intermediate states. The machine always has a current state.If the current state is ever an error state, a vulnerability is reported.
						States are connected by transitions. Each transition has a source state, a destination state, and some number of patterns. If a transition's source state is the current state and one of that transition's patterns matches a fragment of the program, then the transition's destination state becomes the new current state. In this case, the machine is said to have transitioned from the source state to the destination state. The program fragment is referred to as the "input" to the pattern.</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:whiteSpace value="preserve"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
						<xs:element name="Disabled" minOccurs="0" maxOccurs="1">
							<xs:annotation><xs:documentation>Disables the rule.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="optional" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="ControlflowRuleFlag">
		<xs:annotation>
			<xs:documentation>Contains a command that alters the behavior the control flow analyzer.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute name="flagValue" type="xs:boolean" use="required">
						<xs:annotation><xs:documentation>Indicates whether to turn the behavior on or off.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>

	<!--
	 This type definition is not referenced anywhere; it is provided here
	 as a convenient place to document these flags.
	 -->
	<xs:simpleType name="ControlflowFlagValue">
		<xs:annotation>
			<xs:documentation>ControlflowRuleFlag elements may specify the following behaviors:
 "end-of-scope matches nonreturning functions" (default: true) -- determines whether #end_scope() transitions in control flow rules should be matched when a nonreturning function, such as exit(), is called.
 "end-of-function matches nonreturning functions" (default: true) -- determines whether #end_function() transitions in control flow rules should be matched when a nonreturning function, such as exit(), is called.
 "report transitions from a state to itself" (default: true) -- determines whether control flow results should include state transitions where the source and target states are identical.
 "report uses on right-hand side of assignments" (default: false) -- determines whether a transition that uses only a rule variable (such as { f } ) matches when the variable is used on the right-hand side of an assignment.
 "local only" (default: false) -- if true, this rule will not be run interprocedurally. (Selected products only.)</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="end-of-scope matches nonreturning functions"/>
			<xs:enumeration value="end-of-function matches nonreturning functions"/>
			<xs:enumeration value="report transitions from a state to itself"/>
			<xs:enumeration value="report uses on right-hand side of assignments"/>
			<xs:enumeration value="local only"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:element name="ControlflowStateStrings">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Notes" minOccurs="0"/>
				<xs:element name="StateStrings" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="Notes" minOccurs="0"/>
							<xs:element name="Enter" type="xs:string" minOccurs="0" maxOccurs="1"/>
							<xs:element name="Add" minOccurs="0" maxOccurs="unbounded">
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="xs:string">
											<xs:attribute name="varName" type="xs:string" use="required"/>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
							<xs:element name="Remove" minOccurs="0" maxOccurs="unbounded">
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="xs:string">
											<xs:attribute name="varName" type="xs:string" use="required"/>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute name="id" type="xs:string" use="required"/>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Structural Rule - - - -->

	<xs:element name="StructuralRule">
		<xs:annotation>
		<xs:documentation>Much like control flow rules, structural rules comprise a number of common elements shared amongst many rule types along with a special element that contains the rule definition written in a proprietary language used only by this analyzer. The rule definition describes the code constructs against which the rule will match, and therefore is the most important element of the rule definition.
		By default structural rules are not run against JSP code because the tool generated Java code produced from JSP pages includes many code constructs that cause the structural analyzer to produce warnings that would be appropriate in human-generated code, but are unnecessary in tool-generated code. To write a structural rule that will be applied to JSPs, specify the rule language as jsp in the rule definition. If you need to create a structural rule that will be applied to both Java and JSP code, duplicate the rule definition and specify the language as java in one rule and jsp in the other.</xs:documentation></xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:element name="Predicate" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation><![CDATA[In general, a predicate is an expression built up from the following:
--String, integer, and Boolean literals
--Standard binary relations (==, !=, <, >, <=, >=)
--A variety of additional binary relations (is, in, contains, startsWith, endsWith, matches, reaches, reachedBy)
--Boolean connectives (and, or, not)
--Identifiers that refer to properties of the construct]]></xs:documentation>
						</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:whiteSpace value="preserve"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Config & Content Rules - - - -->

	<xs:element name="ConfigFile">
		<xs:annotation>
			<xs:documentation>Defines the type of configuration file.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="matchType">
					<xs:attribute name="type" use="required">
						<xs:annotation>
							<xs:documentation>Indicates the file type.</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="properties"/>
								<xs:enumeration value="xml"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="ConfigurationRule">
		<xs:annotation>
			<xs:documentation>Checks the runtime configuration files of the application for issues. Supports Java-style properties files and XML configration files.  A ConfigurationRule consists of one or more Checks, where each check is a pairing of a config file matcher with a match expression to be run on the files.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:choice minOccurs="1" maxOccurs="1">
							<xs:sequence>
								<xs:element ref="ConfigFile" minOccurs="1" maxOccurs="1"/>
								<xs:choice minOccurs="1" maxOccurs="1">
									<xs:element ref="XPathMatch"/>
									<xs:element ref="PropertyMatch"/>
								</xs:choice>
							</xs:sequence>
							<xs:sequence>
								<xs:annotation>
									<xs:documentation>Since 3.6</xs:documentation>
								</xs:annotation>
								<xs:element name="Check" minOccurs="1" maxOccurs="unbounded">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ConfigFile" minOccurs="1" maxOccurs="1"/>
											<xs:choice minOccurs="1" maxOccurs="1">
												<xs:element ref="XPathMatch"/>
												<xs:element ref="PropertyMatch"/>
											</xs:choice>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
						</xs:choice>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="ContentRule">
		<xs:annotation>
			<xs:appinfo>Since 3.5</xs:appinfo>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:element ref="XPathMatch" minOccurs="0"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="XPathMatch">
		<xs:annotation>
			<xs:documentation>Defines a setting in an XML configuration file. Fortify SCA reports any setting for which the XPath expression returns true or matches a nodeset as an issue.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="expression" type="xs:string">
				<xs:annotation>
					<xs:documentation>Specify an XPath v1.0 expression that describes the vulnerability.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="reporton" type="xs:string" use="optional">
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="PropertyMatch">
		<xs:annotation>
			<xs:documentation>Defines a setting in a property file.  Fortify SCA reports any property definition where the name and the value match the specified expressions as an issue.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="NameMatch" type="matchType" minOccurs="1" maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Set the name of the property. Tag a regular expression with the Pattern element.</xs:documentation>
						</xs:annotation>
				</xs:element>
				<xs:choice minOccurs="0" maxOccurs="1">
					<xs:element name="ValueMatch" type="matchType">
						<xs:annotation>
							<xs:documentation>Set the value in the property that the rule should detect. Tag a regular expression with the Pattern element.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="NotPresent"/>
				</xs:choice>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Alias Rule - - - -->

	<xs:element name="AliasRule">
		<xs:annotation>
			<xs:documentation>Describes a pair of functions or mapping between functions that are semantically equivalent, indicating that rules matching the functions defined in 'To' also match functions defined in 'From'.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="From" type="functionIdentifierType" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Identifies the function the rule matches.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="To" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Identifies a function in the standard library or a function covered by custom rules. The values must match a specific function.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="NamespaceName" type="xs:string" minOccurs="0" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>Matches on the package or namespace in which the function occurs. If not provided the identifier will match only the default namespace.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="ClassName" type="xs:string" minOccurs="0" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>Matches on the function's enclosing class.  If not provided only non-member functions will be matched.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="FunctionName" type="xs:string" minOccurs="1" maxOccurs="1">
										<xs:annotation>
											<xs:documentation>Matches against the function name.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>


	<!-- - - -  Map Rule - - - -->

	<xs:element name="MapRule">
		<xs:annotation>
			<xs:documentation>A map rule is used to describe a type (class or struct) which behaves like a map, where values can be stored and retrieved using keys.  This allows the analysis engine to treat stores and retrieves on the map where the key value is static as equivalent to field accesses and more accurately trace tainted data through maps.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="StoreFunction" type="mapFunction" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation><xs:documentation>Identifies a function that stores data in the map from a given key.</xs:documentation></xs:annotation>
						</xs:element>
						<xs:element name="RetrieveFunction" type="mapFunction" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation><xs:documentation>Identifies a function that retrieves data from the map for a given key.</xs:documentation></xs:annotation>
						</xs:element>
						<xs:element name="ValuesFunction" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation><xs:documentation>Identifies a function that retrieves a full or partial set of values from the map.</xs:documentation></xs:annotation>
							<xs:complexType>
								<xs:complexContent>
									<xs:extension base="functionIdentifierType">
										<xs:sequence>
											<xs:element name="MapArg" type="singleArgumentSpecifier" minOccurs="1" maxOccurs="1">
												<xs:annotation>
													<xs:documentation>Identifies the map argument.</xs:documentation>
												</xs:annotation>
											</xs:element>
											<xs:element name="ValuesArg" type="singleArgumentSpecifier" minOccurs="1" maxOccurs="1">
												<xs:annotation>
													<xs:documentation>Identifies the value argument.</xs:documentation>
												</xs:annotation>
											</xs:element>
										</xs:sequence>
									</xs:extension>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:complexType name="mapFunction">
		<xs:complexContent>
			<xs:extension base="functionIdentifierType">
				<xs:sequence>
					<xs:element name="MapArg" type="singleArgumentSpecifier" minOccurs="1" maxOccurs="1"/>
					<xs:element name="KeyArg" type="singleArgumentSpecifier" minOccurs="1" maxOccurs="1"/>
					<xs:element name="ValueArg" type="singleArgumentSpecifier" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- - - -  Buffer & String Rules - - - -->

	<xs:element name="BufferCopyRule">
		<xs:annotation>
			<xs:documentation>A Describes a function that copies a fixed or variable amount of data from one buffer to another.  A BufferCopyRule helps the analysis engine more accurately analyze the source code by facilitating a more precise analysis of copy operations to determine if buffer bounds violations are possible at a call site.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:all>
						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="1"/>
						<xs:element name="SourceArgument" type="argumentSpecifier" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<!-- todo: single/multi -->
								<xs:documentation>The buffer that contains the data to be copied. Omit for functions that only write data, such as the c function memset.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DestinationArgument" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<!-- todo: single/multi -->
							<xs:annotation>
								<xs:documentation>The buffer to which data will be copied.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="FormatArgument" type="argumentSpecifier" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>If the copy operation is controlled by a format string, as with the c function sprintf, the format string argument should be indicated here.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SourceOffset" type="sizeSpecifier" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>If the copy operation begins copying data from an offset into the source buffer that offset should be specified here.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DestOffset" type="sizeSpecifier" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>If the copy operation begins copying data at an offset into the destination buffer that offset should be specified here.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="DataSize" minOccurs="1" maxOccurs="1"/>
						<xs:element ref="SizeUnits" minOccurs="0" maxOccurs="1"/>
					</xs:all>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="AllocationRule">
		<xs:annotation>
			<xs:documentation>An AllocationRule describes a function which allocates a memory block for use by the program and returns a pointer to that block.  AllocationRules help the analysis engine to determine if memory reads or writes may be out of bounds.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:all>
						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="1"/>
						<xs:element name="DestinationArgument" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The pointer to the allocated memory block.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="DataSize" minOccurs="1" maxOccurs="1"/>
						<xs:element ref="SizeUnits" minOccurs="0" maxOccurs="1"/>
					</xs:all>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="DataSize" type="sizeSpecifier">
		<xs:annotation>
			<xs:documentation>Describes how many units of data are written by the call.</xs:documentation>
		</xs:annotation>
	</xs:element>

	<xs:element name="StringLengthRule">
		<xs:annotation>
			<xs:documentation>A StringLengthRule describes a function which calculates the length of a string.  StringLengthRules help the analyzer track information about the size of null-terminated strings and determine if bounds violations may occur on string copy operations.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:all>
						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="1"/>
						<xs:element name="SourceArgument" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The string argument.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DestinationArgument" type="argumentSpecifier" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The argument by which the string length is returned.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="SizeUnits" minOccurs="0" maxOccurs="1"/>
					</xs:all>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="SizeUnits">
		<xs:annotation>
			<xs:documentation>Describes the size of each unit of data.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="arg" type="argumentSpecifier" use="optional">
				<xs:annotation>
					<xs:documentation>Specifies the parameter that contains the size of unit of data to be copied.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="value" use="optional" type="xs:string">
				<xs:annotation>
					<xs:documentation>Describes the unit of data to be copied. Use an integer to indicate the size in bytes. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Control Rules - - - -->

	<xs:element name="NonReturningRule">
		<xs:annotation>
			<xs:documentation>Describes a function which does not return normally, such as exit(). This rule type is used mainly by the control flow analyzer to determine when a control flow path stops at a particular function instead of continuing through it. This is an informational that assists Fortify SCA rather than a rule to indicate whether or not a vulnerability exists.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:all>
						<xs:element ref="FunctionIdentifier" minOccurs="1"/>
					</xs:all>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="CharacterizationRule">
		<xs:annotation>
			<xs:documentation>Alternative syntax for characterizing function behavior.  Some properties in the Definition section may cause issues to be reported.  If that is the case then the Category, Description, etc can be included in the top level rule.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>

						<!-- Vuln Reporting -->

						<xs:element name="VulnKingdom" type="xs:string" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The name of the Kingdom assigned to issues produced by the rule.</xs:documentation>
						</xs:annotation>						</xs:element>
						<xs:element name="VulnCategory" type="xs:string" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The Category name to be assigned to vulnerabilities produced by the rule.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="VulnSubcategory" type="xs:string" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>The Subcategory name to be assigned to vulnerabilities produced by the rule.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DefaultSeverity" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>A vulnerability produced by this rule will be assigned this serverity value.  Values can range from 1 to 5 (inclusive).</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="1.0"/>
									<xs:maxInclusive value="5.0"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
						<xs:element ref="Description" minOccurs="0" maxOccurs="1"/>

						<!-- Characterization -->

						<xs:choice minOccurs="0" maxOccurs="1">
							<xs:element name="StructuralMatch">
								<xs:simpleType>
									<xs:restriction base="xs:string">
										<xs:whiteSpace value="preserve"/>
									</xs:restriction>
								</xs:simpleType>
							</xs:element>
						</xs:choice>
						<xs:element name="Definition" minOccurs="1" maxOccurs="1">

							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:whiteSpace value="preserve"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="ControlflowActionPrototype">
		<xs:annotation>
			<xs:documentation>The prototype for a control flow action.  Actions are referenced in control flow rules and bound to in characterization rules.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:all>
						<xs:element name="Definition" minOccurs="1" maxOccurs="1">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:whiteSpace value="preserve"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:all>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="DeprecationRule" type="rule">
		<xs:annotation>
			<xs:documentation>FortifyUndocumented</xs:documentation>
		</xs:annotation>
	</xs:element>

	<xs:element name="SuppressionRule" type="rule">
		<xs:annotation>
			<xs:documentation>Can be used in a custom rules file to disable a Fortify rule of the same Rule ID</xs:documentation>
		</xs:annotation>
	</xs:element>

	<!-- - - -  Statistical Rule - - - -->

	<xs:complexType name="ruleList">
		<xs:sequence>
			<xs:element name="RuleRef" minOccurs="1" maxOccurs="unbounded">
				<xs:complexType>
					<xs:attribute name="id" use="required" type="xs:string"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:element name="StatisticalRule">
		<xs:annotation><xs:documentation>FortifyUndocumented</xs:documentation></xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
					<xs:sequence>
						<xs:element name="Positive" minOccurs="1" maxOccurs="1" type="ruleList"/>
						<xs:element name="Negative" minOccurs="1" maxOccurs="1" type="ruleList"/>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="type" use="required" type="xs:string"/>
					<xs:attribute name="mintotal" use="required" type="xs:integer"/>
					<xs:attribute name="minratio" use="required" type="xs:float"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>


	<!-- - - -  Internal Rule - - - -->

	<xs:element name="InternalRule">
		<xs:annotation>
			<xs:documentation>FortifyUndocumented</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="vulnRule">
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>


	<!-- - - -  Global Field Rule - - - -->

	<xs:element name="GlobalFieldRule">
		<xs:annotation>
			<xs:documentation>FortifyUndocumented</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="Match" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:all>
									<xs:element ref="NamespaceName" minOccurs="0" maxOccurs="1"/>
									<xs:element ref="ClassName" minOccurs="1" maxOccurs="1"/>
									<xs:element name="FieldName" type="matchType" minOccurs="0" maxOccurs="1"/>
									<xs:element name="ClassLabel" type="xs:string" minOccurs="0" maxOccurs="1"/>
									<xs:element name="FieldLabel" type="xs:string" minOccurs="0" maxOccurs="1"/>
									<xs:element ref="ApplyTo" minOccurs="0" maxOccurs="1"/>
								</xs:all>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  Global Class Rule - - - -->

	<xs:element name="GlobalClassRule">
		<xs:annotation>
			<xs:documentation>
				http://wiki.fortify.com/display/Analysis/Global+Class+Rules
			</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="Match" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:all>
									<xs:element ref="NamespaceName" minOccurs="0" maxOccurs="1"/>
									<xs:element ref="ClassName" minOccurs="0" maxOccurs="1"/>
									<xs:element name="ClassLabel" type="xs:string" minOccurs="0" maxOccurs="1"/>
									<xs:element ref="ApplyTo" minOccurs="0" maxOccurs="1"/>
								</xs:all>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

    <!-- - - -  Result Filter Rule - - - -->

    <xs:element name="ResultFilterRule">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="rule">
                    <xs:sequence>
                        <xs:element name="Check" type="resultFilterCheck" minOccurs="1" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="resultFilterCheck">
        <xs:sequence>
            <xs:element name="AnalyzerName" minOccurs="1" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="Dominant" type="xs:string" minOccurs="1" maxOccurs="1"/>
                        <xs:element name="Subordinate" type="xs:string" minOccurs="1" maxOccurs="1"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="Category" type="resultFilterFieldMatch" minOccurs="0" maxOccurs="1"/>
            <xs:element name="RuleID" type="resultFilterFieldMatch" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="resultFilterFieldMatch">
        <xs:choice minOccurs="1" maxOccurs="1">
            <xs:element name="SameValue"/>
            <xs:sequence>
                <xs:element name="Dominant" type="matchType" minOccurs="1" maxOccurs="1"/>
                <xs:element name="Subordinate" type="matchType" minOccurs="1" maxOccurs="1"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>


    <!-- - - -  CustomDescriptionRule - - - -->

    <xs:element name="CustomDescriptionRule">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="rule">
                    <xs:sequence>
                        <xs:element name="RuleMatch" minOccurs="1" maxOccurs="unbounded">
                            <xs:complexType>
                                <xs:sequence minOccurs="1" >
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element name="RuleID" type="matchType"/>
                                        <xs:element name="Category" type="matchType"/>
                                        <xs:element name="Subcategory" type="matchType"/>
                                        <xs:element name="DescriptionID" type="matchType"/>
                                    </xs:choice>
                                </xs:sequence>
                            </xs:complexType>
                        </xs:element>
                        <xs:element ref="Description"  minOccurs="1" maxOccurs="1"/>

						<!-- a header to use instead of the default "Custom", see Bug 33136 -->
						<xs:element name="Header" type="xs:string" minOccurs="0" maxOccurs="1"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

	<!-- - - -  ScriptedCallGraphRule - - - -->

	<xs:element name="ScriptedCallGraphRule">
	    <xs:complexType>
	        <xs:complexContent>
	            <xs:extension base="rule">
	                <xs:sequence>
		                <xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="1"/>
		                <xs:element ref="Conditional" minOccurs="0" maxOccurs="1"/>
		                <xs:element name="CallDescription" type="xs:string" minOccurs="1" maxOccurs="1"/>
		                <xs:element name="CallGraphScript" minOccurs="1" maxOccurs="1">
			                <xs:simpleType>
				                <xs:restriction base="xs:string">
					                <xs:whiteSpace value="preserve"/>
				                </xs:restriction>
			                </xs:simpleType>
		                </xs:element>
		                <xs:element name="Arguments" minOccurs="1" maxOccurs="1">
			                <xs:complexType>
				                <xs:simpleContent>
					                <xs:extension base="singleArgumentSpecifier">
						                <xs:attribute name="type" use="required">
							                <xs:simpleType>
								                <xs:restriction base="xs:string">
									                <xs:enumeration value="array"/>
									                <xs:enumeration value="positional"/>
								                </xs:restriction>
							                </xs:simpleType>
						                </xs:attribute>
					                </xs:extension>
				                </xs:simpleContent>
			                </xs:complexType>
		                </xs:element>
	                </xs:sequence>
		            <xs:attribute name="language" use="required" type="languageSpecifier">
			            <xs:annotation>
				            <xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
			            </xs:annotation>
		            </xs:attribute>
	            </xs:extension>
	        </xs:complexContent>
	    </xs:complexType>
	</xs:element>

	<!-- Rules dealing with fields and types -->
	<xs:element name="TypeImplementationRule">
		<xs:annotation>
			<xs:documentation>
				This rule is used to specify implementation types returned by a library function. The implementation type should not be an interface types used in the library, because subtype information of implementation types is used to improve analysis precision. Specifying a return type which is an interface will defeat this purpose.
			</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="rule">
					<xs:sequence>
						<xs:element name="TargetFunction" type="functionIdentifierType" minOccurs="1" maxOccurs="1"/>
						<xs:element name="ReturnImplType" type="xs:string" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									The implementation types returned by this matching function. Ideally, we need to lookup library implementation to figure it out. But this condition can be relaxed to choosing a unique name in the application scope.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="language" use="required" type="languageSpecifier">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<!-- - - -  MetaInfo - - - -->

	<xs:element name="MetaInfo">
		<xs:annotation>
			<xs:documentation>Records extra information about a rule in the form of name-value pairs.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Group" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:string">
								<xs:attribute name="name" type="xs:string" use="optional"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:any minOccurs="0" maxOccurs="unbounded"/> <!-- reserve for future extensions -->
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<!-- - - -  CONDITIONAL  - - - -->
	<xs:element name="Conditional">
		<xs:annotation>
			<xs:documentation>Defines a condition or set of conditions that determine where to apply the rule.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group ref="ConditionalNodes" minOccurs="1" maxOccurs="1"/>
		</xs:complexType>
	</xs:element>

	<xs:group name="ConditionalNodes">
		<xs:choice>
			<xs:element ref="And"/>
			<xs:element ref="Or"/>
			<xs:element ref="Not"/>
			<xs:element ref="IsConstant"/>
			<xs:element ref="IsType"/>
			<xs:element ref="ConstantEq"/>
			<xs:element ref="ConstantGt"/>
			<xs:element ref="ConstantLt"/>
			<xs:element ref="ConstantMatches"/>
			<xs:element ref="TaintFlagSet"/>
		</xs:choice>
	</xs:group>

	<xs:element name="And">
		<xs:annotation>
			<xs:documentation>Contains two or more subelements. Returns true only if all the subnodes are true; if one or more is false, then returns false.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="ConditionalNodes" minOccurs="2" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="Or">
		<xs:annotation>
			<xs:documentation>Returns true if any subnodes evaluate true.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="ConditionalNodes" minOccurs="2" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="Not">
		<xs:annotation>
			<xs:documentation>Evaulates to the logical inverse of the subnode.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group ref="ConditionalNodes" minOccurs="1" maxOccurs="1"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="IsConstant">
		<xs:annotation>
			<xs:documentation>Evaluates to true if the value for the specified argument at the call site can be determined statically.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="argument" type="singleArgumentSpecifier" use="required"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="IsType">
		<xs:annotation>
			<xs:documentation>Evaluates to true if the analysis engine can determine statically that the type of the argument specified at the call site is of the type specified or is a subtype of that type.  If the type of the argument cannot be determined statically or can only be determined to be a supertype of the type specified here this node will evaluate to false.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="NamespaceName" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="ClassName" minOccurs="1" maxOccurs="1"/>
			</xs:sequence>
			<xs:attribute name="argument" type="singleArgumentSpecifier" use="required"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="ConstantEq">
		<xs:annotation>
			<xs:documentation>Evaluates to true if the value for the argument specified at this call site can be determined statically and matches the value specified here.  If the value of the argument cannot be determined statically this node evaluates to false.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="argument" type="singleArgumentSpecifier" use="required"/>
			<xs:attribute name="value" use="required" type="xs:string"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="ConstantGt">
		<xs:annotation>
			<xs:documentation>Evaluates to true if the value for the argument specified at the call site can be determined statically and is a numerical value greater than the value specified here.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="argument" type="singleArgumentSpecifier" use="required"/>
			<xs:attribute name="value" use="required" type="xs:integer"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="ConstantLt">
		<xs:annotation>
			<xs:documentation>Evaluates to true if the value for the argument specified at this call site can be determined statically and is a numerical value less than the value specified here.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="argument" type="singleArgumentSpecifier" use="required"/>
			<xs:attribute name="value" use="required" type="xs:integer"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="ConstantMatches">
		<xs:annotation>
			<xs:documentation>Evaluates to true if the value for the argument specified at this call site is a string argunent, all or part of which can be determined statically and a substring of which matches the pattern specified.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Pattern" minOccurs="1" maxOccurs="1"/>
			</xs:sequence>
			<xs:attribute name="argument" type="singleArgumentSpecifier" use="required">
				<xs:annotation>
					<xs:documentation>Zero indexed position of the argument.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="TaintFlagSet">
		<xs:annotation>
			<xs:documentation>Asserts that the named taint flag is set (dataflow only).</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="taintFlag">
				<xs:annotation>
					<xs:documentation>Asserts that the named taint flag is set (dataflow only).</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:pattern value="[a-zA-Z_][a-zA-Z0-9_]*"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<!-- - - -  FUNCTION IDENTIFIERS  - - - -->

	<xs:element name="FunctionIdentifier" type="functionIdentifierType"/>

	<xs:complexType name="functionIdentifierType">
		<xs:all>
			<xs:element name="MatchExpression" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Can be used to specify a match expression for the function.  Use of MatchExpression is mutually exclusive with NamespaceName/ClassName/FunctionName/Parameters/ReturnType.  Since 3.4</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="NamespaceName" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="ClassName" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="FunctionName" minOccurs="0" maxOccurs="1"/>
			<xs:element name="ClassLabel" type="xs:string" minOccurs="0" maxOccurs="1"/>
			<xs:element name="FunctionLabel" type="xs:string" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="Parameters" minOccurs="0" maxOccurs="1"/>
			<xs:element name="ReturnType" type="xs:string" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>The ReturnType specifier limits the functions matched by the FunctionIdentifier to those functions with the given return type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="ApplyTo" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="Modifiers" minOccurs="0" maxOccurs="1"/>
			<xs:element name="Except" minOccurs="0" maxOccurs="1">
				<xs:complexType>
					<xs:sequence>
						<xs:element ref="FunctionIdentifier" minOccurs="1" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:all>
		<!-- Removed in 3.4 -->
		<!--xs:attribute name="ref" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>Use to refer to function identifiers named elsewhere in the document</xs:documentation>
			</xs:annotation>
		</xs:attribute-->
		<xs:attribute name="id" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>Use to name function identifiers so they can be refered to elsewhere</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:element name="NamespaceName" type="matchType">
		<xs:annotation>
			<xs:documentation>Matches on the package or namespace in which the function occurs. If not provided the identifier will match only the default namespace.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ClassName" type="matchType">
		<xs:annotation>
			<xs:documentation>Matches on the function's enclosing class.  If not provided only non-member functions will be matched.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="FunctionName" type="matchType">
		<xs:annotation>
			<xs:documentation>Matches against the function name.</xs:documentation>
		</xs:annotation>
	</xs:element>

	<xs:element name="Parameters">
		<xs:annotation>
			<xs:documentation>Defining the function parameters allows you to restrict the rule to match only functions that have other specified values and conform to a certain signature (parameter list). Restricting which functions trigger a rule based on the signature is useful in languages that allow function definitions with the same name to be overloaded to accept different parameters..</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="ParamType" type="xs:string" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Strings corresponding to the types of the parameters defined in the specified function. Null or undefined element directs Fortify SCA to match any method or function signature without restriction.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="WildCard" minOccurs="0" maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Integer that represents the minimum or maximum number of arbitrarily typed parameters to match against at the end of the specified function signature. Applies to parameters immediately following any other signature elements entered and cannot precede any such elements.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="min" default="1" use="optional" type="xs:integer">
							<xs:annotation>
								<xs:documentation>Integer that represents the minimum number of arbitrarily typed parameters to match against at the end of the specified function signature.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="max" default="1" use="optional" type="xs:integer">
							<xs:annotation>
								<xs:documentation>Integer that represents the maximum number of arbitrarily typed parameters to match against at the end of the specified function signature.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="varArg" type="xs:boolean" use="optional" default="false">
				<xs:annotation>
					<xs:documentation>Specify whether or not a function has a variable number of arguments</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="FunctionCallIdentifier">
		<xs:complexType>
			<xs:all>
				<xs:element ref="FunctionIdentifier" minOccurs="1"/>
				<xs:element ref="Conditional" minOccurs="0"/>
			</xs:all>
			<xs:attribute name="id" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>Use to name function call identifiers so they can be refered to elsewhere.</xs:documentation>
			</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="ApplyTo">
		<xs:annotation>
			<xs:documentation>Controls how overriding, implementing or extending functions will be matched.
implements - functions which implement an abstract or interface method matched by the FunctionIdentifier will also be matched.
overrides - subtype functions which override a functions matched by the FunctionIdentifier will also be matched.
extends - functions with names and signatures matching the FunctionName and Parameters specifications and which are defined in a type which is a subtype of a type matched by the Namespace and ClassName specifications will be matched.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="implements" type="xs:boolean" default="false">
				<xs:annotation>
					<xs:documentation>True specifies that the function specified in the rule is defined in an interface and that the rule should be triggered by the use of the specified function in any class that implements the specified interface.</xs:documentation>
				</xs:annotation>
				</xs:attribute>
			<xs:attribute name="overrides" type="xs:boolean" default="false">
				<xs:annotation>
					<xs:documentation>True specifies that in addition to matching against the specified function, the rule should also match against overridden definitions of the specified function in classes that inherit from the specified class.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="extends" type="xs:boolean" default="false">
				<xs:annotation>
					<xs:documentation>True specifies that although the specified function is not defined in the specified class, the rule should match against equivalent functions implemented in classes that inherit from the specified class.</xs:documentation>
				</xs:annotation>
				</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="Modifiers">
		<xs:annotation>
			<xs:documentation>Defines the language modifiers that are applied to the function definition.</xs:documentation>
		</xs:annotation>
	<xs:complexType>
			<xs:sequence>
				<xs:element ref="Modifier" minOccurs="1" maxOccurs="unbounded">
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="Modifier">
					<xs:annotation>
						<xs:documentation>Defines the language modifiers that are applied to the function definition with the exception of the webservice.</xs:documentation>
					</xs:annotation>
	<xs:simpleType>
			<xs:restriction base="xs:string">
				<xs:enumeration value="public"/>
				<xs:enumeration value="private"/>
				<xs:enumeration value="protected"/>
				<xs:enumeration value="static"/>
				<xs:enumeration value="final"/>
				<xs:enumeration value="native"/>
				<xs:enumeration value="webservice"/>
			</xs:restriction>
		</xs:simpleType>
	</xs:element>

	<!-- - - -  DESCRIPTIONS  - - - -->

	<xs:element name="Descriptions">
		<xs:annotation>
			<xs:documentation>A section for named description elements references from rules.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Description" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Contains the vulnerability description that appears on the Details and Recommendation panel.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="Abstract" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Brief description that appears on the Summary and Details panel of Audit Workbench.</xs:documentation>
				</xs:annotation>
				</xs:element>
				<xs:element ref="Explanation" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Detailed description of the issue that appears under the Abstract on the Details panel of Audit Workbench.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="Recommendations" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
					<xs:documentation>Provide a detailed description of how to remedy the issue; appears on the Recommendations panel of Audit Workbench.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="Tips" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Provide tips about the issue; appears on the Recommendations panel of Audit Workbench.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="References" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
					<xs:documentation>Provide citations and additional information on the issue; appears on the Details panel of Audit Workbench.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:any minOccurs="0" maxOccurs="unbounded">
					<xs:annotation><xs:documentation>Since 3.3</xs:documentation></xs:annotation>
				</xs:any>
			</xs:sequence>
			<xs:anyAttribute>
				<xs:annotation><xs:documentation>Since 3.3</xs:documentation></xs:annotation>
			</xs:anyAttribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="Description">
					<xs:annotation>
						<xs:documentation>Contains the vulnerability description that appears on the Details and Recommendation panel.</xs:documentation>
					</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="descriptionElement">
					<xs:sequence>
						<xs:element ref="Abstract" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Brief description that appears on the Summary and Details panel of Audit Workbench.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="Explanation" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Detailed description of the issue that appears under the Abstract on the Details panel of Audit Workbench.</xs:documentation>
							</xs:annotation>						</xs:element>
						<xs:element ref="Recommendations" minOccurs="0" maxOccurs="1">
							<xs:annotation>
							<xs:documentation>Provide a detailed description of how to remedy the issue; appears on the Recommendations panel of Audit Workbench.</xs:documentation>
							</xs:annotation>						</xs:element>
						<xs:element ref="Tips" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Provide tips about the issue; appears on the Recommendations panel of Audit Workbench.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="References" minOccurs="0" maxOccurs="1">
							<xs:annotation>
							<xs:documentation>Provide citations and additional information on the issue; appears on the Details panel of Audit Workbench.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ContentType" minOccurs="0" maxOccurs="1">
							<xs:annotation><xs:appinfo>Since 3.3</xs:appinfo></xs:annotation>
							<xs:complexType>
								<xs:attribute name="value" type="xs:string" use="required"/>
							</xs:complexType>
						</xs:element>
						<xs:any minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
					<xs:attribute name="formatVersion" type="xs:string" use="optional">
						<xs:annotation><xs:appinfo>Since 3.4</xs:appinfo></xs:annotation>
					</xs:attribute>
					<xs:anyAttribute>
						<xs:annotation><xs:appinfo>Since 3.3</xs:appinfo></xs:annotation>
					</xs:anyAttribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="Abstract" type="descriptionTextElement">
		<xs:annotation>
			<xs:documentation>Short description of vulnerability.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Explanation" type="descriptionTextElement">
		<xs:annotation>
			<xs:documentation>Explanation part of the description of the vulnerability.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Recommendations" type="descriptionTextElement">
		<xs:annotation>
			<xs:documentation>Recommendation part of the description of the vulnerability.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Tips">
		<xs:annotation>
			<xs:documentation>Auditing tips part of the description of the vulnerability.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Tip" type="descriptionTextElement" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attributeGroup ref="referenceable"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="References">
		<xs:annotation>
			<xs:documentation>Collection of references for the vulnerability</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Reference" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attributeGroup ref="referenceable"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="Reference">
		<xs:annotation>
			<xs:documentation>Reference to information about vulnerability</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="descriptionElement">
					<xs:all>
						<xs:element name="Title" type="xs:string" minOccurs="1"/>
						<xs:element name="Author" type="xs:string" minOccurs="0"/>
						<xs:element name="Publisher" type="xs:string" minOccurs="0"/>
						<xs:element name="PublishedDate" type="xs:gYear" minOccurs="0"/>
						<xs:element name="Pages" type="xs:string" minOccurs="0"/>
						<xs:element name="Source" type="xs:string" minOccurs="0"/>
					</xs:all>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>


	<xs:element name="DestinationArgument" type="xs:int" default="-1"/>
	<xs:element name="ExecutionPathArgument" type="xs:int" default="-1"/>
	<xs:element name="FormatArgument" type="xs:int" default="-1"/>
	<xs:element name="ControlArgument" type="xs:int"/>
	<xs:element name="SourceArgument">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:int">
					<xs:attribute name="type" type="xs:string" use="optional"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
    <xs:element name="RaceArgument">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:int">
					<xs:attribute name="type" type="xs:string" use="optional"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>



	<xs:element name="Pattern">
		<xs:annotation>
			<xs:documentation>A Java-style regular expression to use for matching.  The caseInsensitive, multiline and inStringMatch attributes control how matching is performed.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute name="caseInsensitive" type="xs:boolean" default="false"/>
					<xs:attribute name="multiline" type="xs:boolean" default="false"/>
					<xs:attribute name="inStringMatch" type="xs:boolean" default="false"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>

	<xs:element name="Value">
		<xs:annotation>
			<xs:documentation>A literal string value to match.  The comparison will be case sensitive unless the caseInsensitive attribute is set to true.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute name="caseInsensitive" type="xs:boolean" default="false"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>


	<!-- Taint Flag Declarations -->

	<xs:element name="TaintFlagDeclarations">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Flag" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="name" type="xs:string" use="required"/>
						<xs:attribute name="type" use="optional" default="general">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="specific"/>
									<xs:enumeration value="neutral"/>
									<xs:enumeration value="general"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:anyAttribute>
							<xs:annotation><xs:documentation>Since 3.3</xs:documentation></xs:annotation>
						</xs:anyAttribute>
					</xs:complexType>
				</xs:element>
				<xs:any minOccurs="0" maxOccurs="unbounded">
					<xs:annotation><xs:documentation>Since 3.3</xs:documentation></xs:annotation>
				</xs:any>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="TaintFlagDescriptions">
		<xs:annotation><xs:documentation>Since 3.3</xs:documentation></xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="FlagDescription" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:string">
								<xs:attribute name="name" type="xs:string" use="required"/>
								<xs:anyAttribute/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:any minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<xs:element name="Script" type="scriptType"/>

	<xs:complexType name="scriptType" mixed="true">
		<xs:annotation>
			<xs:documentation>The rule set may contain script elements, written in JavaScript that are executed
				before any of the scripts associated with individual rules.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DependentRules" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>A list of rules which depend on the execution of this script for their correct
						behavior.  If this script is disabled, the dependant rules will not be run.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RuleID" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:any minOccurs="0" maxOccurs="unbounded"/>  <!-- placeholder for future extensions -->
		</xs:sequence>
		<xs:attribute name="formatVersion" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The version of the schema for which the rule is written</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="pre"/>
					<xs:enumeration value="post"/>
					<xs:enumeration value="mid"/>
					<xs:enumeration value="lib"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the script (for error reporting)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute/>
	</xs:complexType>

	<!-- Coverage -->

	<xs:element name="Coverage">
		<xs:annotation>
			<xs:documentation>This section is used to identify the set of APIs covered by this rulepack</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="FunctionIdentifier" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:complexContent>
							<xs:extension base="functionIdentifierType">
								<xs:attribute name="formatVersion" type="xs:string" use="optional"/>
								<xs:attribute name="language" type="languageSpecifier" use="optional">
						<xs:annotation>
							<xs:documentation>Indicates the language for which the rule is written.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
							</xs:extension>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>

	<!-- Localization -->

	<xs:element name="Localization">
		<xs:annotation>
			<xs:documentation>A Localization provides localized string mappings for localizable rule text (category names, etc).  The localization mapping chosen depends on the value of the Locale attribute.  A Localization element with no Locale attribute will be the default Localization.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Mapping" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="KeyString" type="xs:string" minOccurs="1" maxOccurs="1"/>
							<xs:element name="LocalString" type="xs:string" minOccurs="1" maxOccurs="1"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="locale" type="xs:string" use="optional"/>
		</xs:complexType>
	</xs:element>

</xs:schema>
